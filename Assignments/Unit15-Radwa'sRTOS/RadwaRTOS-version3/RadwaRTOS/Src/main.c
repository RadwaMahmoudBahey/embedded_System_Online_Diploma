///**
// ******************************************************************************
// * @file           : main.c
// * @author         : Auto-generated by STM32CubeIDE
// * @brief          : Main program body
// ******************************************************************************
// * @attention
// *
// * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
// * All rights reserved.</center></h2>
// *
// * This software component is licensed by ST under BSD 3-Clause license,
// * the "License"; You may not use this file except in compliance with the
// * License. You may obtain a copy of the License at:
// *                        opensource.org/licenses/BSD-3-Clause
// *
// ******************************************************************************
// */



#include "Scheduler.h"

uint8_t TaskA_LED , TaskB_LED ,TaskC_LED ,TaskD_LED;

Taskref TaskA , TaskB , TaskD ,TaskC;
void Task_A(void){
	static uint8_t count=0;
	while(1){
		TaskA_LED ^= 1;
		count++;
		if(count == 1){
			RadwaRTOS_ACTIVATE_TASK(&TaskD);
		//	count =0;
		}
		RadwaRTOS_TASK_WAIT(&TaskA ,100);
	}
}

void Task_B(void){
	while(1){
		TaskB_LED ^= 1;
		RadwaRTOS_TASK_WAIT(&TaskB , 300);
	}
}



void Task_C(void){
	while(1){
		TaskC_LED ^= 1;
		RadwaRTOS_TASK_WAIT(&TaskC , 500);
	}
}

void Task_D(void){

	static uint32_t count=0;
	while(1){
		TaskD_LED ^= 1;
		count++;
		RadwaRTOS_TASK_WAIT(&TaskD ,1000);
//		if(count ==350){
//			RadwaRTOS_TERMINATE_TASK(&TaskD);
//			count=0;
//		}
	}
}

int main(void)
{
	RadwaRTOS_error error;
	HW_init();
	if (RadwaRTOS_Init() != no_error){
		while(1);
	}

	TaskA.stack_size = 1024;
	TaskA.Priority = 8;
	TaskA.task_entry = Task_A;
	strcpy(TaskA.Task_name , "Task_A");

	TaskB.stack_size = 1024;
	TaskB.Priority = 8;
	TaskB.task_entry = Task_B;
	strcpy(TaskB.Task_name , "Task_B");

	TaskC.stack_size = 1024;
	TaskC.Priority = 8;
	TaskC.task_entry = Task_C;
	strcpy(TaskC.Task_name , "Task_C");

	TaskD.stack_size = 1024;
	TaskD.Priority = 3;
	TaskD.task_entry = Task_D;
	strcpy(TaskD.Task_name , "Task_D");

	error += RadwaRTOS_CREATE_TASK(&TaskA);
	error += RadwaRTOS_CREATE_TASK(&TaskB);
	error += RadwaRTOS_CREATE_TASK(&TaskC);
	error += RadwaRTOS_CREATE_TASK(&TaskD);

	RadwaRTOS_ACTIVATE_TASK(&TaskA);
	RadwaRTOS_ACTIVATE_TASK(&TaskB);
	RadwaRTOS_ACTIVATE_TASK(&TaskC);


	RadwaRTOS_Activate_OS();
	while(1){

	}
	return 0;
}




