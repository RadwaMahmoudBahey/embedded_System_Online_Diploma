///**
// ******************************************************************************
// * @file           : main.c
// * @author         : Auto-generated by STM32CubeIDE
// * @brief          : Main program body
// ******************************************************************************
// * @attention
// *
// * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
// * All rights reserved.</center></h2>
// *
// * This software component is licensed by ST under BSD 3-Clause license,
// * the "License"; You may not use this file except in compliance with the
// * License. You may obtain a copy of the License at:
// *                        opensource.org/licenses/BSD-3-Clause
// *
// ******************************************************************************
// */


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif



#include "Stm32_F103C6_gpio_driver.h"
#include "LCD.h"
#include "KPD.h"

#define ZERO 0x01
#define ONE 0x79
#define TWO 0x24
#define THREE 0x30
#define FOUR 0x58
#define FIVE 0x12
#define SIX 0x02
#define SEVEN 0x19
#define EIGHT 0x00
#define NINE 0x10


#define SEG_7		GPIOB
#define SEG0	PIN9
#define SEG1	PIN10
#define SEG2	PIN11
#define SEG3	PIN12
#define SEG4	PIN13
#define SEG5	PIN14
#define SEG6	PIN15


void SEGMENT(uint8_t returned_value){


	switch(returned_value){
	case '0':
		MCAL_GPIO_WRITE_PORT(GPIOB, (ZERO)<<9);
		return;

	case '1':
		MCAL_GPIO_WRITE_PORT(GPIOB, (ONE)<<9);
		return;
	case '2':
		MCAL_GPIO_WRITE_PORT(GPIOB, (TWO)<<9);
		return;

	case '3':
		MCAL_GPIO_WRITE_PORT(GPIOB, (THREE)<<9);
		return;
	case '4':
		MCAL_GPIO_WRITE_PORT(GPIOB, (FOUR)<<9 );
		return;
	case '5':
		MCAL_GPIO_WRITE_PORT(GPIOB, (FIVE)<<9);
		return;
	case '6':
		MCAL_GPIO_WRITE_PORT(GPIOB, (SIX)<<9);
		return;
	case '7':
		MCAL_GPIO_WRITE_PORT(GPIOB, (SEVEN)<<9);
		return;
	case '8':
		MCAL_GPIO_WRITE_PORT(GPIOB, (EIGHT)<<9);
		return;
	case '9':
		MCAL_GPIO_WRITE_PORT(GPIOB, (NINE)<<9);
		return;
	}
}

void gpio_init(void){
	GPIO_PinConfig_t  pinConfig;

	//initializing 7 segments pins
	pinConfig.PinNo = SEG0;
	pinConfig.Mode = GPIO_MODE_OUTPUT_PP;
	pinConfig.speed =OUTPUT_SPEED_10M;
	MCAL_GPIO_INIT(SEG_7, &pinConfig);

	pinConfig.PinNo = SEG1;
	pinConfig.Mode = GPIO_MODE_OUTPUT_PP;
	pinConfig.speed =OUTPUT_SPEED_10M;
	MCAL_GPIO_INIT(SEG_7, &pinConfig);

	pinConfig.PinNo = SEG2;
	pinConfig.Mode = GPIO_MODE_OUTPUT_PP;
	pinConfig.speed =OUTPUT_SPEED_10M;
	MCAL_GPIO_INIT(SEG_7, &pinConfig);

	pinConfig.PinNo = SEG3;
	pinConfig.Mode = GPIO_MODE_OUTPUT_PP;
	pinConfig.speed =OUTPUT_SPEED_10M;
	MCAL_GPIO_INIT(SEG_7, &pinConfig);

	pinConfig.PinNo = SEG4;
	pinConfig.Mode = GPIO_MODE_OUTPUT_PP;
	pinConfig.speed =OUTPUT_SPEED_10M;
	MCAL_GPIO_INIT(SEG_7, &pinConfig);

	pinConfig.PinNo = SEG5;
	pinConfig.Mode = GPIO_MODE_OUTPUT_PP;
	pinConfig.speed =OUTPUT_SPEED_10M;
	MCAL_GPIO_INIT(SEG_7, &pinConfig);

	pinConfig.PinNo = SEG6;
	pinConfig.Mode = GPIO_MODE_OUTPUT_PP;
	pinConfig.speed =OUTPUT_SPEED_10M;
	MCAL_GPIO_INIT(SEG_7, &pinConfig);
}

void clk_init(void){

	RCC_GPIOA_CLK_EN();
	RCC_GPIOB_CLK_EN();
}

void _wait_ms(uint32_t time) {
	uint32_t i, j;
	for (i = 0; i < time; i++)
		for (j = 0; j < 255; j++)
			;
}
int main(void)
{
	clk_init();
	gpio_init();
	LCD_Init();


	unsigned char LCD_DISPLAY [11] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0'};
	unsigned char DISPLAY [11] = {ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, ZERO};
	for (unsigned char i = 0; i < 11; i++) {
		LCD_Char(LCD_DISPLAY[i]);
		MCAL_GPIO_WRITE_PORT(GPIOB, DISPLAY[i] << 9); /* write data on to the LED port */
		_wait_ms(100);
		/* wait for 1 second */
	}
	KPD_Init();
	while(1){
		char returned_value =KPD_Value();
		switch(returned_value){
		case 'A':
			break;
		case '?':
			LCD_ClearScreen();
			break;
		default:
			LCD_Char(returned_value);
			//SEGMENT(returned_value-'0');
			break;
		}
	}
	return 0;
}



